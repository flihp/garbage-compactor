diff -ru b/contrib/s2geometry/src/s2/s2builder.cc a/contrib/s2geometry/src/s2/s2builder.cc
--- b/contrib/s2geometry/src/s2/s2builder.cc	Thu Dec  9 22:38:41 2021
+++ a/contrib/s2geometry/src/s2/s2builder.cc	Thu Dec  9 22:41:18 2021
@@ -271,7 +271,7 @@
   // error in the calculation to compare this distance against the bound.
   double d = sin(edge_snap_radius);
   edge_snap_radius_sin2_ = d * d;
-  edge_snap_radius_sin2_ += ((9.5 * d + 2.5 + 2 * sqrt(3)) * d +
+  edge_snap_radius_sin2_ += ((9.5 * d + 2.5 + 2 * sqrt(3.0)) * d +
                              9 * DBL_EPSILON) * DBL_EPSILON;
 
   // Initialize the current label set.
@@ -655,7 +655,7 @@
   // expensive and can produce surprising results.  For example, if you snap
   // the polyline "0:0, 0:0.7" using IntLatLngSnapFunction(0), the result is
   // "0:0, 0:0" rather than the expected "0:0, 0:1", because the snap radius
-  // is approximately sqrt(2) degrees and therefore it is legal to snap both
+  // is approximately sqrt(2.0) degrees and therefore it is legal to snap both
   // input points to "0:0".  "Snap first" produces "0:0, 0:1" as expected.
   for (const InputVertexKey& key : SortInputVertices()) {
     const S2Point& vertex = input_vertices_[key.second];
diff -ru b/contrib/s2geometry/src/s2/s2builderutil_snap_functions.cc a/contrib/s2geometry/src/s2/s2builderutil_snap_functions.cc
--- b/contrib/s2geometry/src/s2/s2builderutil_snap_functions.cc	Thu Dec  9 22:38:41 2021
+++ a/contrib/s2geometry/src/s2/s2builderutil_snap_functions.cc	Thu Dec  9 22:41:18 2021
@@ -262,12 +262,12 @@
   //
   // The maximum error when converting the S2LatLng back to an S2Point is
   //
-  //   sqrt(2) * (maximum error in latitude or longitude) + 1.5 * DBL_EPSILON
+  //   sqrt(2.0) * (maximum error in latitude or longitude) + 1.5 * DBL_EPSILON
   //
-  // which works out to (9 * sqrt(2) + 1.5) * DBL_EPSILON radians.  Finally
+  // which works out to (9 * sqrt(2.0) + 1.5) * DBL_EPSILON radians.  Finally
   // we need to consider the effect of rounding to integer coordinates
   // (much larger than the errors above), which can change the position by
-  // up to (sqrt(2) * 0.5 * to_degrees_) radians.
+  // up to (sqrt(2.0) * 0.5 * to_degrees_) radians.
   double power = 1;
   for (int i = 0; i < exponent; ++i) power *= 10;
   return (S1Angle::Degrees(M_SQRT1_2 / power) +
@@ -276,7 +276,7 @@
 
 int IntLatLngSnapFunction::ExponentForMaxSnapRadius(S1Angle snap_radius) {
   // When choosing an exponent, we need to acount for the error bound of
-  // (9 * sqrt(2) + 1.5) * DBL_EPSILON added by MinSnapRadiusForExponent().
+  // (9 * sqrt(2.0) + 1.5) * DBL_EPSILON added by MinSnapRadiusForExponent().
   snap_radius -= S1Angle::Radians((9 * M_SQRT2 + 1.5) * DBL_EPSILON);
   snap_radius = max(snap_radius, S1Angle::Radians(1e-30));
   double exponent = log10(M_SQRT1_2 / snap_radius.degrees());
@@ -296,7 +296,7 @@
   // We return the maximum of the two bounds.
   //
   // 1. Proportional bound: It can be shown that in the plane, the worst-case
-  //    configuration has a vertex separation of (sqrt(2) / 3) * snap_radius.
+  //    configuration has a vertex separation of (sqrt(2.0) / 3) * snap_radius.
   //    This is verified in the unit test, except that on the sphere the ratio
   //    is slightly smaller (0.471337 vs. 0.471404).  We reduce that value a
   //    bit more below to be conservative.
@@ -304,8 +304,8 @@
   // 2. Best asymptotic bound: This bound bound is derived by observing we
   //    only select a new site when it is at least snap_radius() away from all
   //    existing sites, and snapping a vertex can move it by up to
-  //    ((1 / sqrt(2)) * to_degrees_) degrees.
-  return max(0.471 * snap_radius_,        // sqrt(2) / 3 in the plane
+  //    ((1 / sqrt(2.0)) * to_degrees_) degrees.
+  return max(0.471 * snap_radius_,        // sqrt(2.0) / 3 in the plane
              snap_radius_ - S1Angle::Degrees(M_SQRT1_2 * to_degrees_));
 }
 
diff -ru b/contrib/s2geometry/src/s2/s2builderutil_snap_functions.h a/contrib/s2geometry/src/s2/s2builderutil_snap_functions.h
--- b/contrib/s2geometry/src/s2/s2builderutil_snap_functions.h	Thu Dec  9 22:38:41 2021
+++ a/contrib/s2geometry/src/s2/s2builderutil_snap_functions.h	Thu Dec  9 22:41:04 2021
@@ -154,8 +154,8 @@
 //
 // Each exponent has a corresponding minimum snap radius, which is simply the
 // maximum distance that a vertex can move when snapped.  It is approximately
-// equal to 1/sqrt(2) times the nominal point spacing; for example, for
-// snapping to E7 the minimum snap radius is (1e-7 / sqrt(2)) degrees.
+// equal to 1/sqrt(2.0) times the nominal point spacing; for example, for
+// snapping to E7 the minimum snap radius is (1e-7 / sqrt(2.0)) degrees.
 // You can also set the snap radius to any value larger than this; this can
 // result in significant extra simplification (similar to using a larger
 // exponent) but does not move vertices unnecessarily.
@@ -199,7 +199,7 @@
   S1Angle snap_radius() const override;
 
   // Returns the minimum allowable snap radius for the given exponent
-  // (approximately equal to (pow(10, -exponent) / sqrt(2)) degrees).
+  // (approximately equal to (pow(10, -exponent) / sqrt(2.0)) degrees).
   static S1Angle MinSnapRadiusForExponent(int exponent);
 
   // Returns the minimum exponent such that vertices will not move by more
diff -ru b/contrib/s2geometry/src/s2/s2cap_test.cc a/contrib/s2geometry/src/s2/s2cap_test.cc
--- b/contrib/s2geometry/src/s2/s2cap_test.cc	Thu Dec  9 22:38:41 2021
+++ a/contrib/s2geometry/src/s2/s2cap_test.cc	Thu Dec  9 22:41:18 2021
@@ -221,7 +221,7 @@
   // and then check for the expected intersection/containment results.
 
   // The distance from the center of a face to one of its vertices.
-  static const double kFaceRadius = atan(sqrt(2));
+  static const double kFaceRadius = atan(sqrt(2.0));
 
   for (int face = 0; face < 6; ++face) {
     // The cell consisting of the entire face.
diff -ru b/contrib/s2geometry/src/s2/s2edge_crosser.cc a/contrib/s2geometry/src/s2/s2edge_crosser.cc
--- b/contrib/s2geometry/src/s2/s2edge_crosser.cc	Thu Dec  9 22:38:41 2021
+++ a/contrib/s2geometry/src/s2/s2edge_crosser.cc	Thu Dec  9 22:41:18 2021
@@ -48,11 +48,11 @@
   }
   // The error in RobustCrossProd() is insignificant.  The maximum error in
   // the call to CrossProd() (i.e., the maximum norm of the error vector) is
-  // (0.5 + 1/sqrt(3)) * DBL_EPSILON.  The maximum error in each call to
+  // (0.5 + 1/sqrt(3.0)) * DBL_EPSILON.  The maximum error in each call to
   // DotProd() below is DBL_EPSILON.  (There is also a small relative error
   // term that is insignificant because we are comparing the result against a
   // constant that is very close to zero.)
-  static const double kError = (1.5 + 1/sqrt(3)) * DBL_EPSILON;
+  static const double kError = (1.5 + 1/sqrt(3.0)) * DBL_EPSILON;
   if ((c_->DotProd(a_tangent_) > kError && d.DotProd(a_tangent_) > kError) ||
       (c_->DotProd(b_tangent_) > kError && d.DotProd(b_tangent_) > kError)) {
     return -1;
diff -ru b/contrib/s2geometry/src/s2/s2edge_crossings.cc a/contrib/s2geometry/src/s2/s2edge_crossings.cc
--- b/contrib/s2geometry/src/s2/s2edge_crossings.cc	Thu Dec  9 22:38:41 2021
+++ a/contrib/s2geometry/src/s2/s2edge_crossings.cc	Thu Dec  9 22:41:18 2021
@@ -148,7 +148,7 @@
   // input vectors, which eliminates most of the cancellation error.  However
   // the error in the direction of the cross product can still become large if
   // the two points are extremely close together.  We can show that as long as
-  // the length of the cross product is at least (16 * sqrt(3) + 24) * DBL_ERR
+  // the length of the cross product is at least (16 * sqrt(3.0) + 24) * DBL_ERR
   // (about 6e-15), then the directional error is at most 5 * T_ERR (about
   // 3e-19 when T == "long double").  (DBL_ERR appears in the first formula
   // because the inputs are assumed to be normalized in double precision
@@ -158,15 +158,15 @@
   // error.  Letting "result_len" be the length of the cross product, it can
   // be shown that the error is at most
   //
-  //   (2 + 2 * sqrt(3) + 12 / result_len) * T_ERR
+  //   (2 + 2 * sqrt(3.0) + 12 / result_len) * T_ERR
   //
   // We want this error to be at most kIntersectionError, which is true as
   // long as "result_len" is at least kMinResultLen defined below.
 
   constexpr T T_ERR = s2pred::rounding_epsilon<T>();
-  static const T kMinNormalLength = (16 * sqrt(3) + 24) * DBL_ERR;
+  static const T kMinNormalLength = (16 * sqrt(3.0) + 24) * DBL_ERR;
   static const T kMinResultLen =
-      12 / (kIntersectionError.radians() / T_ERR - (2 + 2 * sqrt(3)));
+      12 / (kIntersectionError.radians() / T_ERR - (2 + 2 * sqrt(3.0)));
 
   // On some platforms "long double" is the same as "double", and on these
   // platforms this method always returns false (e.g. ARM, Win32).  Rather
@@ -236,11 +236,11 @@
   // double precision rather than in the given type T.)
   //
   // For reference, the bounds that went into this calculation are:
-  // ||N'-N|| <= ((1 + 2 * sqrt(3))||N|| + 32 * sqrt(3) * DBL_ERR) * T_ERR
+  // ||N'-N|| <= ((1 + 2 * sqrt(3.0))||N|| + 32 * sqrt(3.0) * DBL_ERR) * T_ERR
   // |(A.B)'-(A.B)| <= (1.5 * (A.B) + 1.5 * ||A|| * ||B||) * T_ERR
   // ||(X-Y)'-(X-Y)|| <= ||X-Y|| * T_ERR
   constexpr T T_ERR = s2pred::rounding_epsilon<T>();
-  *error = (((3.5 + 2 * sqrt(3)) * a_norm_len + 32 * sqrt(3) * DBL_ERR)
+  *error = (((3.5 + 2 * sqrt(3.0)) * a_norm_len + 32 * sqrt(3.0) * DBL_ERR)
             * dist + 1.5 * fabs(result)) * T_ERR;
   return result;
 }
diff -ru b/contrib/s2geometry/src/s2/s2edge_distances.cc a/contrib/s2geometry/src/s2/s2edge_distances.cc
--- b/contrib/s2geometry/src/s2/s2edge_distances.cc	Thu Dec  9 22:38:41 2021
+++ a/contrib/s2geometry/src/s2/s2edge_distances.cc	Thu Dec  9 22:41:18 2021
@@ -229,9 +229,9 @@
   // parallel to the plane containing the edge respectively.
   double b = min(1.0, 0.5 * dist.length2());
   double a = sqrt(b * (2 - b));
-  return ((2.5 + 2 * sqrt(3) + 8.5 * a) * a +
-          (2 + 2 * sqrt(3) / 3 + 6.5 * (1 - b)) * b +
-          (23 + 16 / sqrt(3)) * DBL_EPSILON) * DBL_EPSILON;
+  return ((2.5 + 2 * sqrt(3.0) + 8.5 * a) * a +
+          (2 + 2 * sqrt(3.0) / 3 + 6.5 * (1 - b)) * b +
+          (23 + 16 / sqrt(3.0)) * DBL_EPSILON) * DBL_EPSILON;
 }
 
 double GetUpdateMinDistanceMaxError(S1ChordAngle dist) {
diff -ru b/contrib/s2geometry/src/s2/s2edge_distances_test.cc a/contrib/s2geometry/src/s2/s2edge_distances_test.cc
--- b/contrib/s2geometry/src/s2/s2edge_distances_test.cc	Thu Dec  9 22:38:41 2021
+++ a/contrib/s2geometry/src/s2/s2edge_distances_test.cc	Thu Dec  9 22:41:18 2021
@@ -233,9 +233,9 @@
   // Test that interpolation is done using distances on the sphere rather than
   // linear distances.
   CheckInterpolate(1./3, S2Point(1, 0, 0), S2Point(0, 1, 0),
-                   S2Point(sqrt(3), 1, 0));
+                   S2Point(sqrt(3.0), 1, 0));
   CheckInterpolate(2./3, S2Point(1, 0, 0), S2Point(0, 1, 0),
-                   S2Point(1, sqrt(3), 0));
+                   S2Point(1, sqrt(3.0), 0));
 
   // Test that interpolation is accurate on a long edge (but not so long that
   // the definition of the edge itself becomes too unstable).
@@ -425,7 +425,7 @@
   // Standard situation.  Same hemisphere, not degenerate.
   CheckEdgePairMaxDistance(S2Point(1, 0, 0), S2Point(0, 1, 0),
                            S2Point(1, 1, 0), S2Point(1, 1, 1),
-                           acos(1/sqrt(3)));
+                           acos(1/sqrt(3.0)));
 
   // One edge is degenerate.
   CheckEdgePairMaxDistance(S2Point(1, 0, 1), S2Point(1, 0, 1),
diff -ru b/contrib/s2geometry/src/s2/s2edge_tessellator.cc a/contrib/s2geometry/src/s2/s2edge_tessellator.cc
--- b/contrib/s2geometry/src/s2/s2edge_tessellator.cc	Thu Dec  9 22:38:41 2021
+++ a/contrib/s2geometry/src/s2/s2edge_tessellator.cc	Thu Dec  9 22:41:18 2021
@@ -84,13 +84,13 @@
 // error functions must have roots at x = {-1, 1} since the error must be zero
 // at the edge endpoints.  E1 is simply a parabola whose maximum value is 1
 // attained at x = 0, while E2 is a cubic with an additional root at x = 0,
-// and whose maximum value is 2 * sqrt(3) / 9 attained at x = 1 / sqrt(3).
+// and whose maximum value is 2 * sqrt(3.0) / 9 attained at x = 1 / sqrt(3.0).
 //
 // Next, it is convenient to scale these functions so that the both have a
 // maximum value of 1.  E1 already satisfies this requirement, and we simply
 // redefine E2 as
 //
-//   E2(x) = x * (1 - x^2) / (2 * sqrt(3) / 9)
+//   E2(x) = x * (1 - x^2) / (2 * sqrt(3.0) / 9)
 //
 // Now define x0 to be the point where these two functions intersect, i.e. the
 // point in the range (-1, 1) where E1(x0) = E2(x0).  This value has the very
@@ -136,7 +136,7 @@
 //   E1(x) =
 //     asin(sqrt(sin(Pi / 8 * (1 - x)) ^ 2 +
 //               sin(Pi / 4 * (1 - x)) ^ 2 * cos(Pi / 4) * sin(Pi / 4 * x))) /
-//     asin(sqrt((1 - 1 / sqrt(2)) / 2))
+//     asin(sqrt((1 - 1 / sqrt(2.0)) / 2))
 //
 // Note that this function does not need to be evaluated at runtime, it
 // simply affects the calculation of the value x0 where E1(x0) = E2(x0)
diff -ru b/contrib/s2geometry/src/s2/s2edge_tessellator_test.cc a/contrib/s2geometry/src/s2/s2edge_tessellator_test.cc
--- b/contrib/s2geometry/src/s2/s2edge_tessellator_test.cc	Thu Dec  9 22:38:41 2021
+++ a/contrib/s2geometry/src/s2/s2edge_tessellator_test.cc	Thu Dec  9 22:41:18 2021
@@ -349,7 +349,7 @@
   const double dsin2 = dlat * dlat + dlng * dlng * sin(M_PI_4 * x) * M_SQRT1_2;
   const double dsin2_max = 0.5 * (1 - M_SQRT1_2);
   // Note that this is the reciprocal of the value used in the .cc file!
-  const double kScaleFactor = max((2 * sqrt(3) / 9) / (x * (1 - x * x)),
+  const double kScaleFactor = max((2 * sqrt(3.0) / 9) / (x * (1 - x * x)),
                                   asin(sqrt(dsin2_max)) / asin(sqrt(dsin2)));
 
   // Keep track of the average and maximum geometric and parametric errors.
diff -ru b/contrib/s2geometry/src/s2/s2latlng_rect_bounder.cc a/contrib/s2geometry/src/s2/s2latlng_rect_bounder.cc
--- b/contrib/s2geometry/src/s2/s2latlng_rect_bounder.cc	Thu Dec  9 22:38:41 2021
+++ a/contrib/s2geometry/src/s2/s2latlng_rect_bounder.cc	Thu Dec  9 22:41:18 2021
@@ -64,7 +64,7 @@
     // chosen to limit the maximum error in the normal to 3.84 * DBL_EPSILON.
     // It is possible to show that the error is less than this when
     //
-    //   n.Norm() >= 8 * sqrt(3) / (3.84 - 0.5 - sqrt(3)) * DBL_EPSILON
+    //   n.Norm() >= 8 * sqrt(3.0) / (3.84 - 0.5 - sqrt(3.0)) * DBL_EPSILON
     //            = 1.91346e-15 (about 8.618 * DBL_EPSILON)
     double n_norm = n.Norm();
     if (n_norm < 1.91346e-15) {
@@ -114,7 +114,7 @@
       // the error in these calculations.  It is possible to show that the
       // total error is bounded by
       //
-      //  (1 + sqrt(3)) * DBL_EPSILON * n_norm + 8 * sqrt(3) * (DBL_EPSILON**2)
+      //  (1 + sqrt(3.0)) * DBL_EPSILON * n_norm + 8 * sqrt(3.0) * (DBL_EPSILON**2)
       //    = 6.06638e-16 * n_norm + 6.83174e-31
 
       double m_error = 6.06638e-16 * n_norm + 6.83174e-31;
@@ -244,11 +244,11 @@
     // length x = 2*min_abs_lat and y ~= lng_gap.  The desired distance is the
     // length of the third edge "z", and we have
     //
-    //         z  ~=  sqrt(x^2 + y^2)  >=  (x + y) / sqrt(2)
+    //         z  ~=  sqrt(x^2 + y^2)  >=  (x + y) / sqrt(2.0)
     //
     // Therefore the region may contain nearly antipodal points only if
     //
-    //  2*min_abs_lat + lng_gap  <  sqrt(2) * 4.309 * DBL_EPSILON
+    //  2*min_abs_lat + lng_gap  <  sqrt(2.0) * 4.309 * DBL_EPSILON
     //                           ~= 1.354e-15
     //
     // Note that because the given bound B is conservative, "min_abs_lat" and
@@ -264,7 +264,7 @@
     // we have an obtuse triangle XYZ with two edges of length x = lat_gap1
     // and y = lat_gap2, and angle Z >= Pi/2 between them.  We then have
     //
-    //         z  >=  sqrt(x^2 + y^2)  >=  (x + y) / sqrt(2)
+    //         z  >=  sqrt(x^2 + y^2)  >=  (x + y) / sqrt(2.0)
     //
     // Unlike the case above, "lat_gap1" and "lat_gap2" are not lower bounds
     // (because of the extra addition operation, and because M_PI_2 is not
@@ -272,7 +272,7 @@
     // 0.75 * DBL_EPSILON.  Putting this all together, the region may
     // contain nearly antipodal points only if
     //
-    //   lat_gap1 + lat_gap2  <  (sqrt(2) * 4.309 + 1.5) * DBL_EPSILON
+    //   lat_gap1 + lat_gap2  <  (sqrt(2.0) * 4.309 + 1.5) * DBL_EPSILON
     //                        ~= 1.687e-15
     if (lat_gap1 + lat_gap2 < 1.687e-15) {
       return S2LatLngRect::Full();
diff -ru b/contrib/s2geometry/src/s2/s2latlng_rect_bounder_test.cc a/contrib/s2geometry/src/s2/s2latlng_rect_bounder_test.cc
--- b/contrib/s2geometry/src/s2/s2latlng_rect_bounder_test.cc	Thu Dec  9 22:38:41 2021
+++ a/contrib/s2geometry/src/s2/s2latlng_rect_bounder_test.cc	Thu Dec  9 22:41:18 2021
@@ -46,7 +46,7 @@
 
 TEST(RectBounder, MaxLatitudeSimple) {
   // Check cases where the min/max latitude is attained at a vertex.
-  static const double kCubeLat = asin(1 / sqrt(3));  // 35.26 degrees
+  static const double kCubeLat = asin(1 / sqrt(3.0));  // 35.26 degrees
   EXPECT_TRUE(GetEdgeBound(1,1,1, 1,-1,-1).ApproxEquals(  // NOLINT
       S2LatLngRect(R1Interval(-kCubeLat, kCubeLat),
                    S1Interval(-M_PI_4, M_PI_4)), kRectError));
diff -ru b/contrib/s2geometry/src/s2/s2latlng_test.cc a/contrib/s2geometry/src/s2/s2latlng_test.cc
--- b/contrib/s2geometry/src/s2/s2latlng_test.cc	Thu Dec  9 22:38:41 2021
+++ a/contrib/s2geometry/src/s2/s2latlng_test.cc	Thu Dec  9 22:41:18 2021
@@ -123,7 +123,7 @@
     {0, 0, 0, 0},
     {1.5, 91.7, 1.5, 91.7},
     {9.9, -0.31, 9.9, -0.31},
-    {sqrt(2), -sqrt(5), 1.414214, -2.236068},
+    {sqrt(2.0), -sqrt(5.0), 1.414214, -2.236068},
     {91.3, 190.4, 90, -169.6},
     {-100, -710, -90, 10},
   };
diff -ru b/contrib/s2geometry/src/s2/s2measures.cc a/contrib/s2geometry/src/s2/s2measures.cc
--- b/contrib/s2geometry/src/s2/s2measures.cc	Thu Dec  9 22:38:41 2021
+++ a/contrib/s2geometry/src/s2/s2measures.cc	Thu Dec  9 22:41:18 2021
@@ -79,7 +79,7 @@
   //
   // Since we don't know E, we would like a conservative upper bound on
   // the triangle area in terms of s and dmin.  It's possible to show that
-  // E <= k1 * s * sqrt(s * dmin), where k1 = 2*sqrt(3)/Pi (about 1).
+  // E <= k1 * s * sqrt(s * dmin), where k1 = 2*sqrt(3.0)/Pi (about 1).
   // Using this, it's easy to show that we should always use l'Huilier's
   // method if dmin >= k2 * s^5, where k2 is about 1e-2.  Furthermore,
   // if dmin < k2 * s^5, the triangle area is at most k3 * s^4, where
diff -ru b/contrib/s2geometry/src/s2/s2metrics.cc a/contrib/s2geometry/src/s2/s2metrics.cc
--- b/contrib/s2geometry/src/s2/s2metrics.cc	Thu Dec  9 22:38:41 2021
+++ a/contrib/s2geometry/src/s2/s2metrics.cc	Thu Dec  9 22:41:18 2021
@@ -49,8 +49,8 @@
 
 const LengthMetric kMinWidth(
     S2_PROJECTION == S2_LINEAR_PROJECTION ? sqrt(2. / 3) :             // 0.816
-    S2_PROJECTION == S2_TAN_PROJECTION ? M_PI / (2 * sqrt(2)) :        // 1.111
-    S2_PROJECTION == S2_QUADRATIC_PROJECTION ? 2 * sqrt(2) / 3 :       // 0.943
+    S2_PROJECTION == S2_TAN_PROJECTION ? M_PI / (2 * sqrt(2.0)) :        // 1.111
+    S2_PROJECTION == S2_QUADRATIC_PROJECTION ? 2 * sqrt(2.0) / 3 :       // 0.943
     0);
 
 const LengthMetric kMaxWidth(kMaxAngleSpan.deriv());
@@ -63,9 +63,9 @@
     0);
 
 const LengthMetric kMinEdge(
-    S2_PROJECTION == S2_LINEAR_PROJECTION ? 2 * sqrt(2) / 3 :          // 0.943
-    S2_PROJECTION == S2_TAN_PROJECTION ? M_PI / (2 * sqrt(2)) :        // 1.111
-    S2_PROJECTION == S2_QUADRATIC_PROJECTION ? 2 * sqrt(2) / 3 :       // 0.943
+    S2_PROJECTION == S2_LINEAR_PROJECTION ? 2 * sqrt(2.0) / 3 :          // 0.943
+    S2_PROJECTION == S2_TAN_PROJECTION ? M_PI / (2 * sqrt(2.0)) :        // 1.111
+    S2_PROJECTION == S2_QUADRATIC_PROJECTION ? 2 * sqrt(2.0) / 3 :       // 0.943
     0);
 
 const LengthMetric kMaxEdge(kMaxAngleSpan.deriv());
@@ -78,13 +78,13 @@
     0);
 
 const LengthMetric kMinDiag(
-    S2_PROJECTION == S2_LINEAR_PROJECTION ? 2 * sqrt(2) / 3 :          // 0.943
-    S2_PROJECTION == S2_TAN_PROJECTION ? M_PI * sqrt(2) / 3 :          // 1.481
-    S2_PROJECTION == S2_QUADRATIC_PROJECTION ? 8 * sqrt(2) / 9 :       // 1.257
+    S2_PROJECTION == S2_LINEAR_PROJECTION ? 2 * sqrt(2.0) / 3 :          // 0.943
+    S2_PROJECTION == S2_TAN_PROJECTION ? M_PI * sqrt(2.0) / 3 :          // 1.481
+    S2_PROJECTION == S2_QUADRATIC_PROJECTION ? 8 * sqrt(2.0) / 9 :       // 1.257
     0);
 
 const LengthMetric kMaxDiag(
-    S2_PROJECTION == S2_LINEAR_PROJECTION ? 2 * sqrt(2) :              // 2.828
+    S2_PROJECTION == S2_LINEAR_PROJECTION ? 2 * sqrt(2.0) :              // 2.828
     S2_PROJECTION == S2_TAN_PROJECTION ? M_PI * sqrt(2. / 3) :         // 2.565
     S2_PROJECTION == S2_QUADRATIC_PROJECTION ? 2.438654594434021032 :  // 2.439
     0);
@@ -96,9 +96,9 @@
     0);
 
 const AreaMetric kMinArea(
-    S2_PROJECTION == S2_LINEAR_PROJECTION ? 4 / (3 * sqrt(3)) :        // 0.770
-    S2_PROJECTION == S2_TAN_PROJECTION ? (M_PI*M_PI) / (4*sqrt(2)) :   // 1.745
-    S2_PROJECTION == S2_QUADRATIC_PROJECTION ? 8 * sqrt(2) / 9 :       // 1.257
+    S2_PROJECTION == S2_LINEAR_PROJECTION ? 4 / (3 * sqrt(3.0)) :        // 0.770
+    S2_PROJECTION == S2_TAN_PROJECTION ? (M_PI*M_PI) / (4*sqrt(2.0)) :   // 1.745
+    S2_PROJECTION == S2_QUADRATIC_PROJECTION ? 8 * sqrt(2.0) / 9 :       // 1.257
     0);
 
 const AreaMetric kMaxArea(
@@ -111,12 +111,12 @@
 // This is true for all projections.
 
 const double kMaxEdgeAspect = (
-    S2_PROJECTION == S2_LINEAR_PROJECTION ? sqrt(2) :                  // 1.414
-    S2_PROJECTION == S2_TAN_PROJECTION ?  sqrt(2) :                    // 1.414
+    S2_PROJECTION == S2_LINEAR_PROJECTION ? sqrt(2.0) :                  // 1.414
+    S2_PROJECTION == S2_TAN_PROJECTION ?  sqrt(2.0) :                    // 1.414
     S2_PROJECTION == S2_QUADRATIC_PROJECTION ? 1.442615274452682920 :  // 1.443
     0);
 
-const double kMaxDiagAspect = sqrt(3);                             // 1.732
+const double kMaxDiagAspect = sqrt(3.0);                             // 1.732
 // This is true for all projections.
 
 }  // namespace S2
diff -ru b/contrib/s2geometry/src/s2/s2polygon.cc a/contrib/s2geometry/src/s2/s2polygon.cc
--- b/contrib/s2geometry/src/s2/s2polygon.cc	Thu Dec  9 22:38:41 2021
+++ a/contrib/s2geometry/src/s2/s2polygon.cc	Thu Dec  9 22:41:18 2021
@@ -1078,7 +1078,7 @@
   // want the bound in terms of (u = 2 * s - 1) rather than "s" itself.
   // Consulting s2metrics.cc, this value is sqrt(2/3)/2 = sqrt(1/6).
   // Going back to the original problem, this gives:
-  double boundary_tolerance_uv = sqrt(6) * boundary_tolerance.radians();
+  double boundary_tolerance_uv = sqrt(6.0) * boundary_tolerance.radians();
 
   // The first pass yields a collection of simplified polylines that preserve
   // the original cyclic vertex order.
diff -ru b/contrib/s2geometry/src/s2/s2predicates.cc a/contrib/s2geometry/src/s2/s2predicates.cc
--- b/contrib/s2geometry/src/s2/s2predicates.cc	Thu Dec  9 22:38:41 2021
+++ a/contrib/s2geometry/src/s2/s2predicates.cc	Thu Dec  9 22:41:18 2021
@@ -76,7 +76,7 @@
   // compute the maximum error in the determinant.  Using a similar technique
   // to the one used for kMaxDetError, the error is at most
   //
-  //   |d| <= (3 + 6/sqrt(3)) * |A-C| * |B-C| * e
+  //   |d| <= (3 + 6/sqrt(3.0)) * |A-C| * |B-C| * e
   //
   // where e = 0.5 * DBL_EPSILON.  If the determinant magnitude is larger than
   // this value then we know its sign with certainty.
@@ -341,8 +341,8 @@
   // distances as small as DBL_ERR.
   S2Point n = (x - y).CrossProd(x + y);
   double d2 = 0.25 * n.Norm2();
-  *error = ((21 + 4 * sqrt(3)) * DBL_ERR * d2 +
-            32 * sqrt(3) * DBL_ERR * DBL_ERR * sqrt(d2) +
+  *error = ((21 + 4 * sqrt(3.0)) * DBL_ERR * d2 +
+            32 * sqrt(3.0) * DBL_ERR * DBL_ERR * sqrt(d2) +
             768 * DBL_ERR * DBL_ERR * DBL_ERR * DBL_ERR);
   return d2;
 }
@@ -353,14 +353,14 @@
   // In "long double" precision it is worthwhile to compensate for length
   // errors in "x" and "y", since they are only unit length to within the
   // precision of "double".  Otherwise the "d2" error coefficient below would
-  // be (16 * DBL_ERR + (5 + 4 * sqrt(3)) * LD_ERR), which is much larger.
+  // be (16 * DBL_ERR + (5 + 4 * sqrt(3.0)) * LD_ERR), which is much larger.
   // (Dividing by the squared norms of "x" and "y" would also reduce the error
   // constant slightly in the double-precision version, but this is not worth
   // the additional effort.)
   Vector3_ld n = (x - y).CrossProd(x + y);
   long double d2 = 0.25 * n.Norm2() / (x.Norm2() * y.Norm2());
-  *error = ((13 + 4 * sqrt(3)) * LD_ERR * d2 +
-            32 * sqrt(3) * DBL_ERR * LD_ERR * sqrt(d2) +
+  *error = ((13 + 4 * sqrt(3.0)) * LD_ERR * d2 +
+            32 * sqrt(3.0) * DBL_ERR * LD_ERR * sqrt(d2) +
             768 * DBL_ERR * DBL_ERR * LD_ERR * LD_ERR);
   return d2;
 }
@@ -593,7 +593,7 @@
   T n2sin2_r_error = 6 * T_ERR * n2sin2_r;
   T ax2, xDn = (x - GetClosestVertex(x, a0, a1, &ax2)).DotProd(n);
   T xDn2 = xDn * xDn;
-  const T c1 = (((3.5 + 2 * sqrt(3)) * n1 + 32 * sqrt(3) * DBL_ERR) *
+  const T c1 = (((3.5 + 2 * sqrt(3.0)) * n1 + 32 * sqrt(3.0) * DBL_ERR) *
                 T_ERR * sqrt(ax2));
   T xDn2_error = 4 * T_ERR * xDn2 + (2 * fabs(xDn) + c1) * c1;
 
@@ -633,7 +633,7 @@
   // The length of M = X.CrossProd(N) is the cosine of the distance.
   T m2 = x.CrossProd(n).Norm2();
   T m1 = sqrt(m2);
-  T m1_error = ((1 + 8 / sqrt(3)) * n1 + 32 * sqrt(3) * DBL_ERR) * T_ERR;
+  T m1_error = ((1 + 8 / sqrt(3.0)) * n1 + 32 * sqrt(3.0) * DBL_ERR) * T_ERR;
   T m2_error = 3 * T_ERR * m2 + (2 * m1 + m1_error) * m1_error;
 
   // If we are using extended precision, then it is worthwhile to recompute
@@ -684,7 +684,7 @@
   T a1_sign = a1_dir.DotProd(m);
   T n2 = n.Norm2();
   T n1 = sqrt(n2);
-  T n1_error = ((3.5 + 8 / sqrt(3)) * n1 + 32 * sqrt(3) * DBL_ERR) * T_ERR;
+  T n1_error = ((3.5 + 8 / sqrt(3.0)) * n1 + 32 * sqrt(3.0) * DBL_ERR) * T_ERR;
   T a0_sign_error = n1_error * a0_dir.Norm();
   T a1_sign_error = n1_error * a1_dir.Norm();
   if (fabs(a0_sign) < a0_sign_error || fabs(a1_sign) < a1_sign_error) {
@@ -771,8 +771,8 @@
   Vector3<T> nb = (b0 - b1).CrossProd(b0 + b1);
   T na_len = na.Norm(), nb_len = nb.Norm();
   T cos_ab = na.DotProd(nb);
-  T cos_ab_error = ((5 + 4 * sqrt(3)) * na_len * nb_len +
-                    32 * sqrt(3) * DBL_ERR * (na_len + nb_len)) * T_ERR;
+  T cos_ab_error = ((5 + 4 * sqrt(3.0)) * na_len * nb_len +
+                    32 * sqrt(3.0) * DBL_ERR * (na_len + nb_len)) * T_ERR;
   return (cos_ab > cos_ab_error) ? 1 : (cos_ab < -cos_ab_error) ? -1 : 0;
 }
 
@@ -836,9 +836,9 @@
   T bc_len = bc_diff.Norm();
   Vector3<T> mab = nab.CrossProd(ab_sum);
   Vector3<T> mbc = nbc.CrossProd(bc_sum);
-  *error = (((16 + 24 * sqrt(3)) * T_ERR +
+  *error = (((16 + 24 * sqrt(3.0)) * T_ERR +
                 8 * DBL_ERR * (ab_len + bc_len)) * nab_len * nbc_len +
-               128 * sqrt(3) * DBL_ERR * T_ERR * (nab_len + nbc_len) +
+               128 * sqrt(3.0) * DBL_ERR * T_ERR * (nab_len + nbc_len) +
                3 * 4096 * DBL_ERR * DBL_ERR * T_ERR * T_ERR);
   return mab.CrossProd(mbc);
 }
@@ -860,7 +860,7 @@
 
   T z_len = z.Norm();
   T nx_len = nx.Norm();
-  T nx_error = ((1 + 2 * sqrt(3)) * nx_len + 32 * sqrt(3) * DBL_ERR) * T_ERR;
+  T nx_error = ((1 + 2 * sqrt(3.0)) * nx_len + 32 * sqrt(3.0) * DBL_ERR) * T_ERR;
   T result_error = ((3 * T_ERR * nx_len + nx_error) * z_len + z_error * nx_len);
   return (result > result_error) ? 1 : (result < -result_error) ? -1 : 0;
 }
@@ -1174,7 +1174,7 @@
   T n2 = n.Norm2();
   T n1 = sqrt(n2);
   // This factor is used in the error terms of dot products with "n" below.
-  T Dn_error = ((3.5 + 2 * sqrt(3)) * n1 + 32 * sqrt(3) * DBL_ERR) * T_ERR;
+  T Dn_error = ((3.5 + 2 * sqrt(3.0)) * n1 + 32 * sqrt(3.0) * DBL_ERR) * T_ERR;
 
   T cos_r = 1 - 0.5 * r2;
   T sin2_r = r2 * (1 - 0.25 * r2);
@@ -1216,8 +1216,8 @@
   Vector3<T> aXb = (a - b).CrossProd(a + b);  // 2 * a.CrossProd(b)
   T aXb1 = aXb.Norm();
   T sin_d = 0.5 * aXb.DotProd(n);
-  T sin_d_error = (4 * DBL_ERR + (2.5 + 2 * sqrt(3)) * T_ERR) * aXb1 * n1 +
-      16 * sqrt(3) * DBL_ERR * T_ERR * (aXb1 + n1);
+  T sin_d_error = (4 * DBL_ERR + (2.5 + 2 * sqrt(3.0)) * T_ERR) * aXb1 * n1 +
+      16 * sqrt(3.0) * DBL_ERR * T_ERR * (aXb1 + n1);
 
   // If LHS(3) is definitely less than RHS(3), neither site excludes the other.
   T result = abs_lhs3 - sin_d;
diff -ru b/contrib/s2geometry/src/s2/s2predicates.h a/contrib/s2geometry/src/s2/s2predicates.h
--- b/contrib/s2geometry/src/s2/s2predicates.h	Thu Dec  9 22:38:41 2021
+++ a/contrib/s2geometry/src/s2/s2predicates.h	Thu Dec  9 22:41:04 2021
@@ -246,7 +246,7 @@
   // kMaxDetError is the maximum error in computing (AxB).C where all vectors
   // are unit length.  Using standard inequalities, it can be shown that
   //
-  //  fl(AxB) = AxB + D where |D| <= (|AxB| + (2/sqrt(3))*|A|*|B|) * e
+  //  fl(AxB) = AxB + D where |D| <= (|AxB| + (2/sqrt(3.0))*|A|*|B|) * e
   //
   // where "fl()" denotes a calculation done in floating-point arithmetic,
   // |x| denotes either absolute value or the L2-norm as appropriate, and
@@ -257,7 +257,7 @@
   // Applying these bounds to the unit-length vectors A,B,C and neglecting
   // relative error (which does not affect the sign of the result), we get
   //
-  //  fl((AxB).C) = (AxB).C + d where |d| <= (2.5 + 2/sqrt(3)) * e
+  //  fl((AxB).C) = (AxB).C + d where |d| <= (2.5 + 2/sqrt(3.0)) * e
   //
   // which is about 3.6548 * e, or 1.8274 * DBL_EPSILON.
   const double kMaxDetError = 1.8274 * DBL_EPSILON;
diff -ru b/contrib/s2geometry/src/s2/s2testing.cc a/contrib/s2geometry/src/s2/s2testing.cc
--- b/contrib/s2geometry/src/s2/s2testing.cc	Thu Dec  9 22:38:41 2021
+++ a/contrib/s2geometry/src/s2/s2testing.cc	Thu Dec  9 22:41:18 2021
@@ -411,7 +411,7 @@
 double S2Testing::Fractal::max_radius_factor() const {
   // The maximum radius is always attained at either an original triangle
   // vertex or at a middle vertex from the first subdivision step.
-  return max(1.0, offset_fraction_ * sqrt(3) + 0.5);
+  return max(1.0, offset_fraction_ * sqrt(3.0) + 0.5);
 }
 
 void S2Testing::Fractal::GetR2Vertices(vector<R2Point>* vertices) const {
@@ -418,8 +418,8 @@
   // The Koch "snowflake" consists of three Koch curves whose initial edges
   // form an equilateral triangle.
   R2Point v0(1.0, 0.0);
-  R2Point v1(-0.5, sqrt(3)/2);
-  R2Point v2(-0.5, -sqrt(3)/2);
+  R2Point v1(-0.5, sqrt(3.0)/2);
+  R2Point v2(-0.5, -sqrt(3.0)/2);
   GetR2VerticesHelper(v0, v1, 0, vertices);
   GetR2VerticesHelper(v1, v2, 0, vertices);
   GetR2VerticesHelper(v2, v0, 0, vertices);
diff -ru b/contrib/s2geometry/src/s2/s2testing_test.cc a/contrib/s2geometry/src/s2/s2testing_test.cc
--- b/contrib/s2geometry/src/s2/s2testing_test.cc	Thu Dec  9 22:38:41 2021
+++ a/contrib/s2geometry/src/s2/s2testing_test.cc	Thu Dec  9 22:41:18 2021
@@ -85,7 +85,7 @@
 
   // "triangle_perim" is the perimeter of the original equilateral triangle
   // before any subdivision occurs.
-  double triangle_perim = 3 * sqrt(3) * tan(nominal_radius);
+  double triangle_perim = 3 * sqrt(3.0) * tan(nominal_radius);
   double min_length_sum = triangle_perim * pow(expansion_factor, min_level);
   for (int level = min_level; level <= max_level; ++level) {
     expected_num_vertices += NumVerticesAtLevel(level);
diff -ru b/contrib/s2geometry/src/s2/s2edge_clipping.cc a/contrib/s2geometry/src/s2/s2edge_clipping.cc
--- b/contrib/s2geometry/src/s2/s2edge_clipping.cc	Thu Dec  9 22:38:41 2021
+++ a/contrib/s2geometry/src/s2/s2edge_clipping.cc	Thu Dec  9 22:44:47 2021
@@ -356,8 +356,8 @@
   // TODO(ericv): This is a temporary hack until I rewrite S2::RobustCrossProd;
   // it avoids loss of precision in Normalize() when the vector is so small
   // that it underflows.
-  if (max(fabs(n[0]), max(fabs(n[1]), fabs(n[2]))) < ldexp(1, -511)) {
-    n *= ldexp(1, 563);
+  if (max(fabs(n[0]), max(fabs(n[1]), fabs(n[2]))) < ldexp(1.0, -511.0)) {
+    n *= ldexp(1.0, 563.0);
   }  // END OF HACK
   n = n.Normalize();
   S2PointUVW a_tangent = n.CrossProd(a);
